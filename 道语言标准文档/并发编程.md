# 并发编程

## 一、协程

### 1. 协程创建
```go
// 基本协程
协程 函() {
    示("协程执行")
}

// 带参数的协程
协程 函(参数 串) {
    示(参数)
}("参数值")
```

### 2. 协程同步
```go
// 使用同步群组
群 := 创群()        // 创建协程群组
群.添一()          // 群组添加一个协程

协程 函() {
    延 群.减一()    // 协程结束时减少一个
    // 执行任务
}

群.候()           // 等待所有协程完成
```

## 二、通道（通）

### 1. 通道类型
```go
// 无缓冲通道
数通 := 创通(整)

// 带缓冲通道
字通 := 创通(串, 10)

// 只读通道
入通 <-通 整

// 只写通道
出通 通<- 整
```

### 2. 通道操作
```go
// 发送数据
发 数通 <- 42

// 接收数据
值 := <-收 数通

// 关闭通道
闭(数通)

// 检查通道状态
值, 开 := <-收 数通
若 !开 {
    示("通道已关闭")
}
```

## 三、选择语句（择）

### 1. 基本选择
```go
择 {
    值 := <-收 通一:
        示("从通一收到:", 值)
    值 := <-收 通二:
        示("从通二收到:", 值)
    通三 <- 值:
        示("发送到通三")
}
```

### 2. 带超时选择
```go
择 {
    值 := <-收 数通:
        示(值)
    待 2 * 时.秒:
        示("超时")
}
```

## 四、同步原语

### 1. 互斥锁（锁）
```go
体 安全计数 {
    锁 互斥锁
    值 整
}

术 (计 *安全计数) 增() {
    计.锁.锁定()
    延 计.锁.解锁()
    计.值++
}
```

### 2. 读写锁（读写锁）
```go
体 安全映射 {
    锁 读写锁
    数据 图[串]整
}

术 (图 *安全映射) 取(键 串) (整, 判) {
    图.锁.读锁定()
    延 图.锁.读解锁()
    值, 有 := 图.数据[键]
    还 值, 有
}

术 (图 *安全映射) 存(键 串, 值 整) {
    图.锁.写锁定()
    延 图.锁.写解锁()
    图.数据[键] = 值
}
```

### 3. 条件变量（条）
```go
锁 := 创互斥锁()
条 := 创条件(锁)

// 等待条件
条.待()

// 唤醒一个等待者
条.醒()

// 唤醒所有等待者
条.醒全()
```

## 五、并发模式

### 1. 生产者消费者
```go
术 生产者(通 通<- 整) {
    循 i := 0; i < 5; i++ {
        发 通 <- i
    }
    闭(通)
}

术 消费者(通 <-通 整) {
    历 值 := 收 通 {
        示("消费:", 值)
    }
}

// 使用示例
通道 := 创通(整)
协程 生产者(通道)
消费者(通道)
```

### 2. 工作池
```go
术 工作池(任务数 整, 工人数 整) {
    任务 := 创通(整, 任务数)
    结果 := 创通(整, 任务数)

    // 启动工人
    循 w := 0; w < 工人数; w++ {
        协程 工人(任务, 结果)
    }

    // 分发任务
    循 j := 0; j < 任务数; j++ {
        发 任务 <- j
    }
    闭(任务)

    // 收集结果
    循 a := 0; a < 任务数; a++ {
        示(<-收 结果)
    }
}
``` 